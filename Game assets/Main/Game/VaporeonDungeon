<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dungeon Game</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/17.0.2/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/17.0.2/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
<style>
body {
background-color: black;
}
.wall {
width: 100%;
height: 100%;
object-fit: cover;
}
.floor {
width: 100%;
height: 100%;
object-fit: cover;
}
.stair {
position: absolute;
width: 100%;
height: 100%;
object-fit: cover;
z-index: 10;
}
.counter {
position: absolute;
top: 10px;
right: 10px;
color: white;
font-size: 24px;
font-weight: bold;
z-index: 10;
}
.player-sprite {
position: absolute;
width: 100%;
height: 100%;
transition: background-image 0.5s ease-in-out;
}
.menu {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background-color: rgba(0, 0, 0, 0.8);
border: 2px solid white;
border-radius: 8px;
padding: 20px;
z-index: 20;
}
.menu button {
margin: 5px;
}
.options-menu {
display: flex;
flex-direction: column;
}
.options-menu label {
color: white;
}
.moves-menu {
display: flex;
flex-direction: column;
}
.moves-menu p {
color: white;
}
.red-border {
border: 2px solid transparent;
border-image: linear-gradient(to right, red, transparent) 1;
}
</style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const vaporeonSprites = [
'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Pokemon%20Sprites/Vaporeon/animations/frames/idle/IdleanimD1.png',
'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Pokemon%20Sprites/Vaporeon/animations/frames/idle/IdleanimD2.png'
];

const vaporeonLeftSprites = [
'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Pokemon%20Sprites/Vaporeon/animations/frames/idle/IdleanimL1.png',
'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Pokemon%20Sprites/Vaporeon/animations/frames/idle/IdleanimL2.png'
];

const vaporeonRightSprites = [
'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Pokemon%20Sprites/Vaporeon/animations/frames/idle/IdleanimR1.png',
'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Pokemon%20Sprites/Vaporeon/animations/frames/idle/IdleanimR2.png'
];

const vaporeonUpSprites = [
'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Pokemon%20Sprites/Vaporeon/animations/frames/idle/IdleanimU1.png',
'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Pokemon%20Sprites/Vaporeon/animations/frames/idle/IdleanimU2.png'
];
const vaporeonDownWalkSprites = [
'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Pokemon%20Sprites/Vaporeon/animations/frames/walk/WalkanimD1Padded.png',
'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Pokemon%20Sprites/Vaporeon/animations/frames/walk/WalkanimD2Padded.png',
'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Pokemon%20Sprites/Vaporeon/animations/frames/walk/WalkanimD3Padded.png',
'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Pokemon%20Sprites/Vaporeon/animations/frames/walk/WalkanimD4Padded.png'
]

const wallSpriteLeft = 'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Tiles/Area1/EditedwallSpritesheet164l.png';
const wallSpriteRight = 'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Tiles/Area1/EditedwallSpritesheet167r.png';
const wallSpriteUp = 'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Tiles/Area1/EditedwallSpritesheet001u.png';
const wallSpriteDown = 'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Tiles/Area1/EditedwallSpritesheet186d.png';
const cornerSpriteTopLeft = 'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Tiles/Area1/EditedwallSpritesheet000tl.png'; // Updated to new top left corner sprite
const cornerSpriteTopRight = 'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Tiles/Area1/EditedwallSpritesheet003tr.png'; // Updated to new top right corner sprite
const cornerSpriteBottomLeft = 'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Tiles/Area1/EditedwallSpritesheet124bl.png'; // Updated to new bottom left corner sprite
const cornerSpriteBottomRight = 'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Tiles/Area1/EditedwallSpritesheet159br.png';
const floorSprites = [
'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Tiles/Area1/EditedfloorSpritesheet068%231.png',
'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Tiles/Area1/EditedfloorSpritesheet070%232.png',
'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Tiles/Area1/EditedfloorSpritesheet116%233.png',
'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/Tiles/Area1/EditedfloorSpritesheet117%234.png'
];
const stairSprite = 'https://raw.githubusercontent.com/jm9698/Misc-SmartTool-Projects/refs/heads/main/Game%20assets/General%20sprites/StairsWithTile.png';
const roomCases = {
0: "Open Room",
1: "Alternate Room"
};

const getRandomRoom = () => {
const randomIndex = Math.floor(Math.random() * Object.keys(roomCases).length);
return randomIndex;
};

const Game = () => {
const [playerPos, setPlayerPos] = React.useState({ x: 15, y: 15 });
const [dungeon, setDungeon] = React.useState([]);
const [stairs, setStairs] = React.useState({ x: 0, y: 0 });
const [floor, setFloor] = React.useState(1);
const [zoomLevel, setZoomLevel] = React.useState(1);
const [cameraTransform, setCameraTransform] = React.useState('');
const [idleSpriteIndex, setIdleSpriteIndex] = React.useState(0); // Index for idle animation
const [walkSpriteIndex, setWalkSpriteIndex] = React.useState(0); // Index for walk animation
const [lastDirection, setLastDirection] = React.useState('down'); // Default direction
const [isPaused, setIsPaused] = React.useState(false); // New paused state
const [showOptions, setShowOptions] = React.useState(false); // State for options menu
const [showMoves, setShowMoves] = React.useState(false); // State for moves menu
const [isShiftPressed, setIsShiftPressed] = React.useState(false); // State to track Shift key
const [isAiming, setIsAiming] = React.useState(false); // Track whether player is aiming
const [showIndicators, setShowIndicators] = React.useState(false); // State to track indicator visibility
const [isWalking, setIsWalking] = React.useState(false); // State to track walking
React.useEffect(() => {
generateDungeon();
}, [floor]);

React.useEffect(() => {
const handleKeyDown = (e) => {
if (e.key === 'Shift') {
setIsShiftPressed(true); // Set Shift pressed state to true
setShowIndicators(prev => !prev); // show indicators
}

let newX = playerPos.x;
let newY = playerPos.y;

switch (e.key) {
case 'w':
if (!isAiming) newY -= 1; // Move up unless Shift is pressed
setLastDirection('up');
break;
case 's':
if (!isAiming){ 
newY += 1; // Move down unless Shift is pressed
setIsWalking(true);
setTimeout(() => {
setIsWalking(false);
}, 3000);
}
setLastDirection('down');
break;
case 'a':
if (!isAiming) newX -= 1; // Move left unless Shift is pressed
setLastDirection('left');
break;
case 'd':
if (!isAiming) newX += 1; // Move right unless Shift is pressed
setLastDirection('right');
break;
case 'Escape': // Escape key to toggle pause
setIsPaused(prev => !prev);
break;
case 'Shift': // Shift key to toggle aim mode
setIsAiming(prev => !prev);
return;
default:
return;
}

// Check for collision with walls only if not paused and not holding Shift
if (!isAiming && !isPaused && newY >= 0 && newY < 30 && newX >= 0 && newX < 30 && dungeon[newY][newX] !== 'W' && !isShiftPressed) {
setPlayerPos({ x: newX, y: newY });
updateCamera(newX, newY);
}

if (newX === stairs.x && newY === stairs.y) {
alert('You found the stairs! Level up!');
setFloor((prevFloor) => prevFloor + 1);
}
};

const handleKeyUp = (e) => {
if (e.key === 'Shift') {
setIsShiftPressed(false); // Set Shift pressed state to false
}
};

window.addEventListener('keydown', handleKeyDown);
window.addEventListener('keyup', handleKeyUp);
return () => {
window.removeEventListener('keydown', handleKeyDown);
window.removeEventListener('keyup', handleKeyUp);
};
}, [playerPos, stairs, dungeon, isPaused, isShiftPressed]); // Add isShiftPressed to dependencies

React.useEffect(() => {
const interval = setInterval(() => {
  if (!isPaused && !isWalking) { // Update idle only if not paused or walking
    if (lastDirection === 'left') {
      setIdleSpriteIndex((prevIndex) => (prevIndex + 1) % vaporeonLeftSprites.length);
    } else if (lastDirection === 'right') {
      setIdleSpriteIndex((prevIndex) => (prevIndex + 1) % vaporeonRightSprites.length);
    } else if (lastDirection === 'up') {
      setIdleSpriteIndex((prevIndex) => (prevIndex + 1) % vaporeonUpSprites.length);
    } else {
      setIdleSpriteIndex((prevIndex) => (prevIndex + 1) % vaporeonSprites.length);
    }
  } else if (!isPaused && isWalking) { // Update walk if not paused but walking
    setWalkSpriteIndex((prevIndex) => (prevIndex + 1) % vaporeonDownWalkSprites.length);
  }
}, 500); // Change sprite every 500ms
return () => clearInterval(interval);
}, [lastDirection, isPaused, isWalking]); // Add isWalking to dependencies


const generateDungeon = () => {
const newDungeon = Array.from({ length: 30 }, () => Array(30).fill(' '));

// Get random room type
const roomType = getRandomRoom();

// Create walls around the dungeon
for (let i = 0; i < 30; i++) {
newDungeon[0][i] = 'W'; // Top wall
newDungeon[29][i] = 'W'; // Bottom wall
newDungeon[i][0] = 'W'; // Left wall
newDungeon[i][29] = 'W'; // Right wall
}

// Generate walls based on room type
if (roomType === 0) { // Open Room
for (let col = 1; col < 29; col++) {
newDungeon[1][col] = getRandomFloorTile(); // Center row as floor tiles
}
} else if (roomType === 1) { // Alternate Room
newDungeon[15][1] = 'W'; // wall placement for Alternate Room
newDungeon[15][2] = 'W';
newDungeon[15][3] = 'W';
newDungeon[15][4] = 'W';
newDungeon[15][5] = 'W';
newDungeon[15][6] = 'W';
newDungeon[15][7] = 'W';
newDungeon[15][8] = 'W';
newDungeon[15][9] = 'W';
newDungeon[15][10] = 'W';
newDungeon[15][11] = 'W';
newDungeon[15][12] = 'W';
newDungeon[15][13] = 'W';
newDungeon[15][16] = 'W';
newDungeon[15][17] = 'W';
newDungeon[15][18] = 'W';
newDungeon[15][19] = 'W';
newDungeon[15][20] = 'W';
newDungeon[15][21] = 'W';
newDungeon[15][22] = 'W'; 
newDungeon[15][23] = 'W';
newDungeon[15][24] = 'W';
newDungeon[15][25] = 'W';
newDungeon[15][26] = 'W';
newDungeon[15][27] = 'W';
newDungeon[15][28] = 'W';
for (let col = 3; col < 29; col++) {
newDungeon[1][col] = getRandomFloorTile(); // Center row as floor tiles
}
}

// Randomly generate stairs position
const stairX = Math.floor(Math.random() * 28) + 1; // Random x position within bounds
const stairY = Math.floor(Math.random() * 28) + 1; // Random y position within bounds
newDungeon[stairY][stairX] = 'S'; // Set stairs in the dungeon

let playerX, playerY;
do {
playerX = Math.floor(Math.random() * 28) + 1; // Keep player within bounds
playerY = Math.floor(Math.random() * 28) + 1; // Keep player within bounds
} while (playerX === stairX && playerY === stairY);

setStairs({ x: stairX, y: stairY });
setPlayerPos({ x: playerX, y: playerY });
setDungeon(newDungeon.map(row => row.map(cell => (cell === ' ' ? getRandomFloorTile() : cell))));
updateCamera(playerX, playerY);
};

const getRandomFloorTile = () => {
return floorSprites[Math.floor(Math.random() * floorSprites.length)];
};

const updateCamera = (x, y) => {
const offsetX = (15 - x + 1) * 40 + 20;
const offsetY = (15 - y - 8.5) * 40 + 20;
setCameraTransform(`translate(${offsetX}px, ${offsetY}px) scale(${zoomLevel})`);
};

const getLineCoordinates = (direction) => {
const lineCoords = [];
let x = playerPos.x;
let y = playerPos.y;

for (let i = 0; i < 30; i++) { // Extend infinitely until hitting a wall
if (direction === 'up' && y - i >= 0) {
if (dungeon[y - i][x] === 'W') break; // Stop if it hits a wall
lineCoords.push({ x: x, y: y - i });
} else if (direction === 'down' && y + i < 30) {
if (dungeon[y + i][x] === 'W') break; // Stop if it hits a wall
lineCoords.push({ x: x, y: y + i });
} else if (direction === 'left' && x - i >= 0) {
if (dungeon[y][x - i] === 'W') break; // Stop if it hits a wall
lineCoords.push({ x: x - i, y: y });
} else if (direction === 'right' && x + i < 30) {
if (dungeon[y][x + i] === 'W') break; // Stop if it hits a wall
lineCoords.push({ x: x + i, y: y });
}
}
return lineCoords;
};

const lineCoordinates = showIndicators ? getLineCoordinates(lastDirection) : [];

return (
<div className="game-area p-4">
<div className="counter">Floor: {floor}</div>
<div className="dungeon-container">
<div className="dungeon" style={{ transform: cameraTransform }}>
  {dungeon.map((row, rowIndex) => (
    <div key={rowIndex} className="dungeon-row flex">
      {row.map((cell, colIndex) => {
        let wallSprite;

        // Determine sprite based on position
        if (cell === 'W') {
          if (rowIndex === 0 && colIndex === 0) {
            wallSprite = cornerSpriteTopLeft; // Updated to new top left corner sprite
          } else if (rowIndex === 0 && colIndex === 29) {
            wallSprite = cornerSpriteTopRight; // Updated to new top right corner sprite
          } else if (rowIndex === 29 && colIndex === 0) {
            wallSprite = cornerSpriteBottomLeft; // Updated to new bottom left corner sprite
          } else if (rowIndex === 29 && colIndex === 29) {
            wallSprite = cornerSpriteBottomRight; // Use bottom right corner sprite
          } else if (rowIndex === 0) {
            wallSprite = wallSpriteUp; // Use wallSpriteUp for top walls
          } else if (rowIndex === 29) {
            wallSprite = wallSpriteDown; // Use wallSpriteDown for bottom wall
          } else if (colIndex === 0) {
            wallSprite = wallSpriteLeft; // Use wallSpriteLeft for left walls
                        } else if (colIndex === 29) {
              wallSprite = wallSpriteRight; // Right border wall
            } else {
              wallSprite = wallSpriteUp; // Use wallSpriteUp for center walls
            }
          }

          const isIndicatorVisible = lineCoordinates.some(coord => coord.x === colIndex && coord.y === rowIndex) && !(playerPos.x === colIndex && playerPos.y === rowIndex);

          return (
            <div key={colIndex} className={`dungeon-cell relative w-10 h-10 ${isIndicatorVisible && showIndicators ? 'red-border' : ''}`}>
              {cell === 'W' ? (
                <img src={wallSprite} alt="Wall" className="wall absolute" />
              ) : (
                <img src={cell} alt="Floor" className="floor absolute" />
              )}
              {cell === 'S' && (
                <img src={stairSprite} alt="Stairs" className="stair absolute" />
              )}
              {playerPos.x === colIndex && playerPos.y === rowIndex && (
                <img 
                  src={
                      isWalking 
                         ? (lastDirection === 'left' ? vaporeonLeftSprites[idleSpriteIndex] 
                          : lastDirection === 'right' ? vaporeonRightSprites[idleSpriteIndex] 
                          : lastDirection === 'up' ? vaporeonUpSprites[idleSpriteIndex] 
                          : lastDirection === 'down' ? vaporeonDownWalkSprites[walkSpriteIndex] 
                          : vaporeonSprites[idleSpriteIndex])
                          : (lastDirection === 'left' ? vaporeonLeftSprites[idleSpriteIndex] 
                          : lastDirection === 'right' ? vaporeonRightSprites[idleSpriteIndex] 
                          : lastDirection === 'up' ? vaporeonUpSprites[idleSpriteIndex] 
                          : lastDirection === 'down' ? vaporeonSprites[idleSpriteIndex] 
                          : vaporeonSprites[idleSpriteIndex]) // Default sprite when not walking
                  }
                  alt="Vaporeon" 
                  className="player-sprite absolute" 
              />
              )}
            </div>
          );
        })}
      </div>
    ))}
  </div>
  {isPaused && !showOptions && !showMoves && ( // Show main menu when paused
    <div className="menu">
      <h2 className="text-white text-lg">Paused</h2>
      <div className="flex">
        <button className="bg-blue-500 text-white p-2 rounded" onClick={() => setShowMoves(true)}>Moves</button>
        <button className="bg-blue-500 text-white p-2 rounded" onClick={() => { /* Handle Underneath */ }}>Underneath</button>
        <button className="bg-blue-500 text-white p-2 rounded" onClick={() => setShowOptions(true)}>Options</button>
        <button className="bg-red-500 text-white p-2 rounded" onClick={() => setIsPaused(false)}>Close</button>
      </div>
    </div>
  )}
  {isPaused && showOptions && ( // Show options menu when options are clicked
    <div className="menu options-menu">
      <h2 className="text-white text-lg">Options</h2>
      <label>
        <input type="checkbox" /> Checkbox 1
      </label>
      <label>
        <input type="checkbox" /> Checkbox 2
      </label>
      <label>
        <input type="checkbox" /> Checkbox 3
      </label>
      <button className="bg-blue-500 text-white p-2 rounded" onClick={() => setShowOptions(false)}>Back</button>
    </div>
  )}
  {isPaused && showMoves && ( // Show moves menu when Moves is clicked
    <div className="menu moves-menu">
      <h2 className="text-white text-lg">Moves</h2>
      <p className="text-white">Water Pulse - 10/10 PP</p>
      <p className="text-white">Aqua Tail - 15/15 PP</p>
      <p className="text-white">Acid Armor - 30/30 PP</p>
      <p className="text-white">Refresh - 10/10 PP</p>
      <button className="bg-blue-500 text-white p-2 rounded" onClick={() => setShowMoves(false)}>Back</button>
    </div>
  )}
</div>
</div>
);
};

// Render the Game component
ReactDOM.render(<Game />, document.getElementById('root'));
</script>
</body>
</html>
